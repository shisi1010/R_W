# 概念模型
 实体: 客观存在的并可相互区别的事物
 
 属性: 实体所具有的某一特性

 码: 唯一标识实体的属性(学号是学生的码)

 实体型: 用实体名及其属性名的集合来抽象和刻画同类实体(如: 学生(学号,姓名,性别,所在院系))

实体集: 同一类型的实体的集合称为实体集

联系: 实体集之间的联系 有一对一　一对多　多对多等类型

　
# 数据模型
通常由数据结构、数据操作、数据的完整性约束条件三部分组成

## 数据结构

#### 层次模型
特点:树型　有且只有一个节点没有双亲(根)　其他节点都只有一个双亲节点

优点: 结构清晰简单、查询效率高 有向边　指针实现
良好的完整性支持　适合一对多

缺点: 实体间多对多不合适　多对一表示笨拙
#### 网状模型
特点:　允许一个以上的节点没有双亲　节点可以有多余一个的双亲节点

优点: 直接描述现实世界　存取效率高

缺点: 结构复杂　不利掌握 DDL DML不易使用
#### 关系模型
关系:通常是一张表 
元组:表中的行
属性:表中的列
码:能唯一确定一个元组 如　学号在学生表中
域:相同数据类型的值的集合 如　性别的域是(男，女)
分量:元组中的一个属性值

关系的每一个分量都必须是不可分割的

优点:概念单一　更高数据独立性 安全保密性
缺点:存取路径不可见 查询需要优化
### 数据操作

对数据库中各种对象(型)的实例(值)允许操作的集合

主要有　查询和更新(增删改)

### 完整性约束条件
如PRIMARY KEY ,NOT NULL

# SQL 概述

sql
外模式: 视图１ 视图２ ...
模式:　基本表１　基本表２ ...　
内模式: 存储文件1 ....

视图是一个虚表　从一个或几个基本表中导出的表


一、对SQL SELECT查询语句进行优化的理由
　　下列几方面的原因是我们进行SQL语句优化的理由：
　　 SQL语句是对数据库(数据)进行*作的惟一途径；
　　 SQL语句消耗了70%~90%的数据库资源；
　　 SQL语句独立于程序设计逻辑，相对于对程序源代码的优化，对SQL语句的优化在时间成本和风险上的代价都很低；
　　 SQL语句可以有不同的写法；
　　 SQL语句易学，难精通。
　　从大多数数据库应用系统的实例来看，查询*作在各种数据库*作中所占据的比重最大，而查询*作所基于的SQL SELECT语句又是代价最大的语句。
　　二、对SQL SELECT查询语句的优化建议
　　（1）、合理使用索引：where子句中变量顺序应与索引字键顺序相同。
　　如：create index test_idx on test(hm, rq, xx)
　　 　　 索引字键顺序：首先是号码hm，其次是日期rq，最后是标志xx，所以where子句变量顺序应是where hm<=“P1234”and rq=“06/06/1999”and xx=“DDD”,不应是where xx=“DDD” and rq=“06/06/1999” and hm <=“P1234”这样的不按索引字键顺序写法。
　　（2）、将最具有限制性的条件放在前面，大值在前，小值在后。
　　　 　如：where colA<=10000 AND colA>=1　效率高
　　 　　 where colA>=1 AND colA<=10000 效率低
　　（3）、避免采用MATCHES和LIKE通配符匹配查询
　　通配符匹配查询特别耗费时间。即使在条件字段上建立了索引，在这种情况下也还是采用顺序扫描的方式。
　　例如语句：SELECT ＊ FROM customer WHERE zipcode MATCHES “524*”
　　可以考虑将它改为SELECT ＊ FROM customer WHERE ZipCode<=“524999” AND ZipCode >=“524000”，则在执行查询时就会利用索引来查询，显然会大大提高速度。
　　（4）、避免非开始的子串
　　例如语句：SELECT ＊ FROM customer WHERE zipcode[2，3] >“24”，在where子句中采用了非开始子串，因而这个语句也不会使用索引。
　　（5）、避免相关子查询
　　一个字段的标签同时在主查询和where子句中的查询中出现，那么很可能当主查询中的字段值改变之后，子查询必须重新查询一次。查询嵌套层次越多，效率越低，因此应当尽量避免子查询。如果子查询不可避免，那么要在子查询中过滤掉尽可能多的行。
　　例如：将下面的语句
　　select hm,rq from TabA
　　where item IN (select item form TabB where TabB.num=50)
　　改为：select hm,bf from TabA, TabB
　　 where TabA.item=TabB.item AND TabB.num=50
　　（6）、避免或简化排序
　　 应当简化或避免对大型表进行重复的排序。当能够利用索引自动以适当的次序产生输出时，优化器就避免了排序的步骤。以下是一些影响因素：
　　 索引中不包括一个或几个待排序的字段；
　　 group by或order by子句中字段的次序与索引的次序不一样；
　　 排序的字段来自不同的表。
　　 为了避免不必要的排序，就要正确地增建索引，合理地合并数据库表（尽管有时可能影响表的规范化，但相对于效率的提高是值得的）。如果排序不可避免，那么应当试图简化它，如缩小排序的字段的范围等。
　　（7）、消除对大型表行数据的顺序存取
　　 在嵌套查询中，对表的顺序存取对查询效率可能产生致命的影响。比如采用顺序存取策略，一个嵌套3层的查询，如果每层都查询1000行，那么这个查询就要查询10亿行数据。避免这种情况的主要方法就是对连接的字段进行索引。例如，两个表：学生表（学号、姓名、年龄……）和选课表（学号、课程号、成绩）。如果两个表要做连接，就要在“学号”这个连接字段上建立索引。
　　 还可以使用并集来避免顺序存取。尽管在所有的检查列上都有索引，但某些形式的where子句强迫优化器使用顺序存取。下面的查询将强迫对orders表执行顺序*作：
　　 SELECT ＊ FROM orders WHERE (cust_num=126 AND order_num>1001) OR order_num=1008
　　 虽然在cust_num和order_num上建有索引，但是在上面的语句中优化器还是使用顺序存取路径扫描整个表。因为这个语句要检索的是分离的行的集合，所以应该改为如下语句：
　　 SELECT ＊ FROM orders WHERE cust_num=126 AND order_num>1001
　　 UNION
　　 SELECT ＊ FROM orders WHERE order_num=1008
　　 这样就能利用索引路径处理查询。
　　（8）、对于大数据量的求和应避免使用单一的sum命令处理，可采用group by方式与其结合，有时其效率可提高几倍甚至百倍。
　　（9）、避免会引起磁盘读写的rowid*作。在where子句中或select语句中，用rowid要产生磁盘读写，是一个物理过程，会影响性能。
　　最后一个就是使用临时表加速查询
　　 把表的一个子集进行排   序并创建临时表，有时能加速查询。它有助于避免多重排序*作，而且在其他方面还能简化优化器的工作。
　  担醒大家一定要注意的是：临时表创建后不会反映主表的修改。在主表中数据频繁修改的情况下，注意不要丢失数据。